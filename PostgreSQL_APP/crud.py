from sqlalchemy.orm import Session
# This will allow you to declare the type of the db parameters and have better type checks and completion in your functions.

from . import models, schemas
# The . import is used to import the models and schemas from the same directory as the current file. This is the same as from PostgreSQL_APP import models, schemas.


def get_user(db: Session, user_id: int):
    return db.query(models.User).filter(models.User.id == user_id).first()


def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()


def get_users(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.User).offset(skip).limit(limit).all()


def create_user(db: Session, user: schemas.UserCreate):
    fake_hashed_password = user.password + "notreallyhashed"
    db_user = models.User(
        email=user.email, hashed_password=fake_hashed_password)
    db.add(db_user)
    # The db.add(db_user) will add the user to the database session, so it will be stored in the database when we call db.commit().
    db.commit()
    # The db.commit() will persist the user in the database, so it will be available in subsequent queries.
    db.refresh(db_user)
    # The db.refresh(db_user) will update the user object in place with the data that was generated by the database on insert, such as the id field, which was generated by the database sequence.
    return db_user
# The create_user function will receive a user Pydantic model, create a SQLAlchemy User model, write it to the database and return the created user.


def get_items(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Item).offset(skip).limit(limit).all()


def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int):
    db_item = models.Item(**item.dict(), owner_id=user_id)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item
